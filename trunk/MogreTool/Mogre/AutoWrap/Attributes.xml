<?xml version="1.0" encoding="utf-8" ?>
<meta>
  <namespace name="Ogre">

    <!--
    <class name="ShadowCaster" Overridable=""/>
    <class name="SceneManager" Overridable=""/>
    <class name="Node" Overridable=""/>
    -->

    <!-- Wrap this class is not necesary for Unicode Support-->
    <class name="UTFString" Ignore=""/>
    <class name="Pass">
      <!-- Must handle "operator()" function first -->
      <class name="HashFunc" Ignore=""/>
    </class>
    <class name="UnifiedHighLevelGpuProgram">
      <!-- There are conflicts with addListener/removeListener from the base Resource class -->
      <function name="addListener" Ignore=""/>
      <function name="removeListener" Ignore=""/>
    </class>

    <class name="AnimationTrack">
      <!-- They are internal methods, and std::vector<Real> as parameter isn't getting wrapped properly at the moment -->
      <function name="_collectKeyFrameTimes" Ignore=""/>
      <function name="_buildKeyFrameIndexMap" Ignore=""/>
    </class>
    <class name="ParticleSystemRenderer">
      <!-- They are internal methods, and std::list<Particle*> as parameter isn't getting wrapped properly at the moment -->
      <function name="_notifyParticleMoved" Ignore=""/>
      <function name="_notifyParticleCleared" Ignore=""/>
    </class>
    <class name="Mesh">
      <!-- parameter 'const Matrix4* const* blendMatrices' is not handled properly at the moment -->
      <function name="softwareVertexBlend" Ignore=""/>
    </class>

    <class name="TimeIndex" WrapType="CLRHandle"/>
    <class name="VisibleObjectsBoundsInfo" WrapType="NativePtrValueType"/>
    <class name="ShadowTextureConfig" WrapType="ValueType"/>
    <class name="Plugin" WrapType="Interface"/>
    <class name="InstancedGeometry">
      <class name="GeometryBucket" Ignore=""/>
      <class name="LODBucket" Ignore=""/>
      <class name="MaterialBucket" Ignore=""/>
      <class name="OptimisedSubMeshGeometry" Ignore=""/>
      <class name="QueuedGeometry" Ignore=""/>
      <class name="QueuedSubMesh" Ignore=""/>
      <class name="SubMeshLodGeometryLink" Ignore=""/>
      <class name="InstancedObject" WrapType="CLRHandle"/>
      <class name="BatchInstance">
        <function name="getObjectsAsArray" Ignore=""/>
      </class>
    </class>
    <class name="EdgeData">
      <!-- for some wierd reason the wrapping of its type doesn't work -->
      <variable name="triangleFaceNormals" Ignore=""/>
    </class>
    <!-- the "typedef std::map<size_t, GpuLogicalIndexUse> GpuLogicalIndexUseMap;" cannot currently be wrapped
        because GpuLogicalIndexUse doesn't have a default constructor -->
    <struct name="GpuLogicalIndexUse" Ignore=""/>

    <class name="Mesh">
      <function name="prepareMatricesForVertexBlend" Ignore=""/>
    </class>
    <class name="ArchiveFactory" Ignore=""/>
    <struct name="FileInfo" WrapType="NativePtrValueType"/>
    <class name="ParameterDef" WrapType="NativePtrValueType"/>
    <class name="ParamCommand" CustomClass=""/>
    <class name="ParamDictionary" WrapType="NativePtrValueType" ReadOnly=""/>
    <class name="StringInterface" WrapType="Interface"/>
    <class name="StringConverter" WrapType="PlainWrapper"/>
    <class name="Any" Ignore=""/>
    <class name="AnyNumeric" Ignore=""/>
    <class name="LayerBlendModeEx" WrapType="NativePtrValueType"/>
    <class name="DynLibManager" Ignore=""/>
    <class name="TempBlendedBufferInfo" Ignore=""/>
    <class name="HardwareBufferLicensee" Ignore=""/>
    <class name="FreeImageCodec" Ignore=""/>
    <class name="Font">
      <struct name="GlyphInfo" WrapType="ValueType"/>
    </class>
    <class name="WindowEventListener" WrapType="Interface"/>
    <class name="WindowEventUtilities" WrapType="PlainWrapper">
      <!-- These are Ogre internals -->
      <variable name="_msListeners" Ignore=""/>
      <variable name="_msWindows" Ignore=""/>
    </class>

    <class name="BillboardSet">
      <variable name="mRadixSorter" Ignore=""/>
    </class>
    <class name="ParticleSystem">
      <variable name="mRadixSorter" Ignore=""/>
    </class>

    <class name="DefaultSceneManager" Ignore=""/>
    <class name="ResourceGroupManager">
      <struct name="ResourceDeclaration" WrapType="NativePtrValueType"/>
      <typedef name="ResourceDeclarationList" STLListNoRemoveAndUnique=""/>
      <!--= It's protected -->
      <struct name="ResourceGroup" Ignore=""/>
    </class>
    <class name="ScriptLoader" Ignore=""/>
    <class name="DefaultHardwareVertexBuffer" Ignore=""/>
    <class name="DefaultHardwareIndexBuffer" Ignore=""/>
    <class name="DefaultHardwareBufferManager" Ignore=""/>
    <class name="ControllerManager" Ignore=""/>
    <class name="ControllerValueRealPtr" Ignore=""/>
    <class name="ControllerFunctionRealPtr" Ignore=""/>
    <class name="ManualResourceLoader" WrapType="Interface"/>
    <class name="MaterialSerializer" WrapType="PlainWrapper"/>
    <class name="CompositorSerializer" WrapType="PlainWrapper"/>
    <!-- to avoid name clash with System.Exception -->
    <class name="Exception" WrapType="PlainWrapper" ReadOnly="" Rename="OgreException"/>
    <class name="EdgeData" WrapType="CLRHandle">
      <struct name="Triangle" WrapType="NativePtrValueType"/>
      <struct name="Edge" WrapType="NativePtrValueType"/>
      <struct name="EdgeGroup" WrapType="NativePtrValueType"/>
    </class>
    <class name="HighLevelGpuProgramFactory" Ignore=""/>
    <struct name="GpuConstantDefinition" WrapType="NativePtrValueType"/>
    <struct name="GpuNamedConstants" WrapType="NativePtrValueType"/>
    <struct name="GpuLogicalBufferStruct" WrapType="NativePtrValueType"/>
    <class name="GpuProgramParameters" WrapType="CLRHandle">
      <struct name="AutoConstantDefinition" WrapType="NativePtrValueType"/>
      <struct name="AutoConstantEntry" WrapType="NativePtrValueType"/>
    </class>

    <class name="RenderSystem">
      <class name="Listener" WrapType="NativeDirector"/>
    </class>
    <class name="CompositorManager">
      <function name="createImpl" Ignore=""/>
    </class>
    <class name="Image" WrapType="CLRHandle">
      <function name="loadDynamicImage">
        <param name="pData" RawPointerParam=""/>
      </function>
    </class>
    <class name="VertexBoneAssignment_s" WrapType="ValueType" Rename="VertexBoneAssignment"/>
    <class name="MeshLodUsage" WrapType="PlainWrapper"/>
    <!-- It's empty, meant for subclassing -->
    <class name="ParticleVisualData" Ignore=""/>
    <class name="ParticleSystemRenderer">
      <function name="_updateRenderQueue" Ignore=""/>
    </class>
    <class name="ParticleSystemRendererFactory" Ignore=""/>
    <class name="Particle" WrapType="CLRHandle"/>
    <class name="ParticleIterator" WrapType="PlainWrapper"/>
    <class name="ParticleSystemManager">
      <function name="getRendererFactoryIterator" Ignore=""/>
    </class>
    <!-- class name="Profiler" Ignore=""/ -->
    <class name="AutoParamDataSource" Ignore=""/>
    <class name="Renderable" WrapType="Interface"/>
    <class name="RenderQueue">
      <class name="RenderableListener" WrapType="Interface"/>
    </class>
    <struct name="RenderablePass" WrapType="NativePtrValueType" ReadOnly=""/>
    <class name="QueuedRenderableVisitor" WrapType="Interface"/>
    <class name="QueuedRenderableCollection" WrapType="PlainWrapper"/>
    <class name="RenderTarget">
      <class name="Impl" Ignore=""/>
    </class>
    <class name="Resource">
      <class name="Listener" WrapType="NativeDirector"/>
    </class>
    <class name="ResourceBackgroundQueue">
      <class name="Listener" WrapType="Interface"/>
      <!-- It gets a Ogre::Resource::Listener object parameter and in Mogre we replaced that with events -->
      <function name="_queueFireBackgroundLoadingComplete" Ignore=""/>
    </class>
    <class name="SceneManager">
      <class name="SkyBoxGenParameters" WrapType="ReadOnlyStruct"/>
      <class name="SkyDomeGenParameters" WrapType="ReadOnlyStruct"/>
      <class name="SkyPlaneGenParameters" WrapType="ReadOnlyStruct"/>
      <!-- protected classes -->
      <class name="ShadowCasterSceneQueryListener" Ignore=""/>
      <class name="SceneMgrQueuedRenderableVisitor" Ignore=""/>
    </class>
    <class name="ViewPoint" WrapType="ReadOnlyStruct"/>
    <class name="Timer" WrapType="PlainWrapper"/>
    <class name="Root">
      <!-- Root's MovableObjectFactoryMap is private -->
      <class name="MovableObjectFactoryIterator" Ignore=""/>
    </class>
    <struct name="LinkedSkeletonAnimationSource" WrapType="NativePtrValueType" ReadOnly=""/>
    <class name="StaticGeometry">
      <class name="SubMeshLodGeometryLink" WrapType="NativePtrValueType" DefinitionIndex="0"/>
      <class name="QueuedGeometry" WrapType="NativePtrValueType"/>
      <class name="GeometryBucket" Ignore=""/>
      <class name="LODBucket" WrapType="CLRHandle"/>
      <class name="MaterialBucket" WrapType="CLRHandle"/>
      <class name="QueuedSubMesh" Ignore=""/>
      <class name="Region">
        <function name="dump" Ignore=""/>
      </class>
    </class>
    <class name="VertexBoneAssignment" WrapType="ValueType"/>
    <class name="SubMesh">
      <variable name="mLodFaceList" Ignore=""/>
    </class>
    <class name="IlluminationPass" WrapType="NativePtrValueType"/>
    <class name="BillboardChain">
      <class name="Element" WrapType="NativePtrValueType"/>
    </class>
    <class name="HardwareBufferManager">
      <function name="_forceReleaseBufferCopies" Ignore=""/>
    </class>
    <class name="CompositorInstance">
      <class name="RenderSystemOperation" Ignore=""/>
      <class name="TargetOperation" Ignore=""/>
    </class>

    <!-- they are _OgrePrivate -->
    <class name="MeshSerializerImpl" Ignore=""/>
    <class name="MeshSerializerImpl_v1_2" Ignore=""/>
    <class name="MeshSerializerImpl_v1_1" Ignore=""/>

    <class name="VertexDeclaration">
      <typedef name="VertexElementList" ReadOnly=""/>
    </class>

    <class name="Node">
      <class name="Listener" WrapType="Interface"/>
    </class>

    <class name="AxisAlignedBox" PureManagedClass=""/>
    <class name="Matrix3" PureManagedClass="m00" NativeValueContainer=""/>
    <class name="Matrix4" PureManagedClass="m00" NativeValueContainer=""/>

    <struct name="_ConfigOption" WrapType="NativePtrValueType" Rename="ConfigOption"/>
    <typedef name="ConfigOption" Rename="ConfigOption_NativePtr"/>

    <class name="VertexData">
      <struct name="HardwareAnimationData" WrapType="NativePtrValueType"/>
    </class>
    <class name="CompositionTechnique">
      <class name="TextureDefinition" WrapType="NativePtrValueType"/>
    </class>

    <struct name="RenderTargetEvent" WrapType="NativePtrValueType" ReadOnly=""/>
    <struct name="RenderTargetViewportEvent" WrapType="NativePtrValueType" ReadOnly=""/>

    <class name="RenderTarget">
      <struct name="FrameStats" WrapType="ReadOnlyStruct" ReturnOnlyByMethod=""/>
    </class>
    <struct name="SceneManagerMetaData" WrapType="NativePtrValueType" ReadOnly=""/>
    <class name="VertexPoseKeyFrame">
      <struct name="PoseRef" WrapType="ValueType" ReadOnly=""/>
      <typedef name="PoseRefList" ReadOnly=""/>
    </class>
    <struct name="FrameEvent" WrapType="ValueType"/>

    <class name="FrameListener">
      <function name="frameStarted" DefaultReturnValue="true"/>
      <function name="frameEnded" DefaultReturnValue="true"/>
    </class>

    <typedef name="SceneTypeMask" ReplaceBy="SceneType"/>
    <enumeration name="SceneType" FlagsEnum=""/>

    <class name="ConfigFile" WrapType="PlainWrapper">
      <function name="load" NoDefaultParamOverloads=""/>
    </class>
    <class name="DataStream" WrapType="PlainWrapper" NoFinalizer=""/>
    <class name="MemoryDataStream" WrapType="PlainWrapper" NoFinalizer="">
      <function name="MemoryDataStream" HideParamsWithDefaultValues="">
        <param name="freeOnClose" Ignore=""/>
      </function>
    </class>
    <class name="ResourceManager" WrapType="PlainWrapper"/>

    <class name="SceneQueryResult" WrapType="PlainWrapper"/>
    <class name="RaySceneQueryResultEntry" WrapType="PlainWrapper"/>
    <class name="IntersectionSceneQueryResult" WrapType="PlainWrapper"/>
    <class name="SceneQuery">
      <struct name="WorldFragment" WrapType="PlainWrapper"/>
      <function name="getSupportedWorldFragmentTypes" Ignore=""/>
    </class>
    <class name="SceneQueryListener" WrapType="Interface"/>
    <class name="RaySceneQueryListener" WrapType="Interface"/>
    <class name="IntersectionSceneQueryListener" WrapType="Interface"/>

    <class name="RenderOperation" WrapType="CLRHandle">
      <enumeration name="OperationType" Rename="OperationTypes"/>
    </class>
    <class name="VertexData" WrapType="CLRHandle"/>
    <class name="TextureUnitState" WrapType="CLRHandle"/>
    <class name="Technique" WrapType="CLRHandle"/>
    <class name="SubMesh" WrapType="CLRHandle"/>
    <class name="SimpleSpline" WrapType="CLRHandle"/>
    <class name="RotationalSpline" WrapType="CLRHandle"/>
    <class name="RenderSystemCapabilities" WrapType="CLRHandle"/>
    <class name="RenderQueueGroup" WrapType="CLRHandle"/>
    <class name="RenderPriorityGroup" WrapType="CLRHandle"/>
    <class name="PatchSurface" WrapType="CLRHandle"/>
    <class name="Pass" WrapType="CLRHandle"/>
    <class name="CompositionTargetPass" WrapType="CLRHandle"/>
    <class name="CompositionPass" WrapType="CLRHandle"/>
    <class name="Billboard" WrapType="CLRHandle"/>
    <class name="AnimationStateSet" WrapType="CLRHandle"/>
    <class name="IndexData" WrapType="CLRHandle"/>
    <class name="PlaneBoundedVolume" WrapType="CLRHandle" DoCleanupInFinalizer=""/>
    <class name="Log" WrapType="CLRHandle"/>

    <class name="ColourValue" ValueType=""/>
    <class name="Plane" ValueType=""/>
    <class name="Quaternion" ValueType=""/>
    <class name="Degree" ValueType=""/>
    <class name="Radian" ValueType=""/>
    <class name="Ray" ValueType=""/>
    <class name="Rectangle" ValueType=""/>
    <class name="Sphere" ValueType=""/>
    <class name="Vector2" ValueType=""/>
    <class name="Vector3" ValueType=""/>
    <class name="Vector4" ValueType=""/>
    <class name="FloatRect" ValueType=""/>
    <class name="Rect" ValueType=""/>
    <class name="Box" ValueType=""/>
    <class name="PixelBox" ValueType=""/>
    <class name="VertexElement" ReadOnlyForFields="" PureManagedClass="data">
      <_CustomIncClassDefinition>
        // Can't use a value class inside an array unless it's fully defined.
        // Include the ported VertexElement definition.
        // Update: I changed it to ref class but keep it this way in case it goes back to being value
        #include "Custom\MogreVertexElement.i"
      </_CustomIncClassDefinition>
    </class>

    <class name="SceneNode">
      <function name="showBoundingBox" Rename="setShowBoundingBox"/>
    </class>
    <class name="RenderQueueInvocationSequence">
      <function name="iterator" Rename="getIterator"/>
    </class>

    <class name="MovablePlane" BaseClass="MovableObject"/>

    <!-- To include all the enums from OgreCommon.h -->
    <class name="TextureFilterOptions" WrapType="NonOverridable"/>
    <!-- To include all the enums from OgrePixelFormat.h -->
    <class name="PixelFormat" WrapType="NonOverridable"/>
    <!-- To include all the enums from OgreBlendMode.h -->
    <class name="LayerBlendType" WrapType="NonOverridable"/>
    <!-- To include all the enums from OgreLog.h -->
    <class name="LoggingLevel" WrapType="NonOverridable"/>

    <class name="TextureUnitState">
      <struct name="TextureEffect" WrapType="NativePtrValueType"/>
      <struct name="UVWAddressingMode" WrapType="ValueType" />
      <function name="_getAnimController" Ignore=""/>
    </class>

    <class name="MovableObject">
      <class name="Listener" WrapType="Interface"/>
      <!-- If isVisible is property it gets hidden by the Frustum::isVisible method -->
      <function name="isVisible" Method=""/>
      <_CustomIncDeclaration>
        protected:
        Object^ _userObject;
        public:
        property Object^ UserObject
        {
        Object^ get() { return _userObject; }
        void set(Object^ obj) { _userObject = obj; }
        }
      </_CustomIncDeclaration>
    </class>

    <class name="Frustum">
      <!-- Resolves ambiguity for proxy class (MovablePlane/Plane) -->
      <function name="enableReflection" ExplicitCastingForParams=""/>
      <function name="enableCustomNearClipPlane" ExplicitCastingForParams=""/>
    </class>

    <class name="Root">
      <_CustomDisposing>
        // Collect all SharedPtr objects that are waiting for finalization
        System::GC::Collect();
        System::GC::WaitForPendingFinalizers();
        System::GC::Collect();
      </_CustomDisposing>
    </class>

    <class name="AnimableObject" WrapType="Interface">
    </class>

    <class name="RenderTarget">
      <function name="setActive" property="" Rename="setIsActive"/>
      <function name="setAutoUpdated" property="" Rename="setIsAutoUpdated"/>
    </class>

    <class name="Overlay">
      <function name="_getWorldTransforms" Ignore=""/>
    </class>

    <class name="AnimationState" WrapType="NonOverridable">
      <function name="getAnimationName" Cached=""/>
    </class>

    <class name="SceneManager" WrapType="NonOverridable">
      <function name="getName" Cached=""/>
      <function name="getRenderQueue" Cached=""/>
      <function name="showBoundingBoxes" Rename="setShowBoundingBoxes"/>
    </class>

    <class name="LogListener" WrapType="NativeDirector"/>
    <class name="ShadowListener" WrapType="NativeDirector">
      <function name="sortLightsAffectingFrustum" DefaultReturnValue="false"/>
    </class>
    <class name="RenderQueueListener" WrapType="NativeDirector"/>
    <class name="ResourceGroupListener" WrapType="NativeDirector"/>
    <class name="FrameListener" WrapType="NativeDirector" StopDelegationForReturn="false"/>
    <class name="RenderTargetListener" WrapType="NativeDirector"/>
    <class name="CompositorInstance">
      <class name="Listener" WrapType="NativeDirector"/>
    </class>

    <class name="Camera">
      <function name="forwardIntersect">
        <_CustomIncDeclaration>
          void ForwardIntersect(Mogre::Plane worldPlane, [Out] array&lt;Mogre::Vector4>^% intersect3d);
        </_CustomIncDeclaration>
        <_CustomCppDeclaration>
          void Camera::ForwardIntersect(Mogre::Plane worldPlane, array&lt;Mogre::Vector4>^% intersect3d)
          {
          std::vector&lt;Ogre::Vector4> vec;
          static_cast&lt;Ogre::Camera*>(_native)->forwardIntersect( worldPlane, &amp;vec);
          intersect3d = GetArrayFromVector&lt;Mogre::Vector4, std::vector&lt;Ogre::Vector4> >(vec);
          }
        </_CustomCppDeclaration>
      </function>
    </class>

    <class name="PixelUtil" WrapType="PlainWrapper">
      <function name="getBitDepths">
        <_CustomIncDeclaration>
          static void GetBitDepths( Mogre::PixelFormat format, [Out] array&lt;int>^% rgba );
        </_CustomIncDeclaration>
        <_CustomCppDeclaration>
          void PixelUtil::GetBitDepths( Mogre::PixelFormat format, array&lt;int>^% rgba )
          {
          rgba = gcnew array&lt;int>(4);
          pin_ptr&lt;int> ptr = &amp;rgba[0];
          Ogre::PixelUtil::getBitDepths( (Ogre::PixelFormat)format, ptr );
          }
        </_CustomCppDeclaration>
      </function>
      <function name="getBitMasks">
        <_CustomIncDeclaration>
          static void GetBitMasks( Mogre::PixelFormat format, [Out] array&lt;uint32>^% rgba );
        </_CustomIncDeclaration>
        <_CustomCppDeclaration>
          void PixelUtil::GetBitMasks( Mogre::PixelFormat format, array&lt;uint32>^% rgba )
          {
          rgba = gcnew array&lt;uint32>(4);
          pin_ptr&lt;uint32> ptr = &amp;rgba[0];
          Ogre::PixelUtil::getBitMasks( (Ogre::PixelFormat)format, ptr );
          }
        </_CustomCppDeclaration>
      </function>
    </class>

    <class name="MeshManager">
      <_CustomIncDeclaration>
        public: generic&lt;typename T> where T : value class
        Mogre::PatchMeshPtr^ CreateBezierPatch( String^ name, String^ groupName, array&lt;T>^ controlPointArray, Mogre::VertexDeclaration^ declaration, size_t width, size_t height, size_t uMaxSubdivisionLevel, size_t vMaxSubdivisionLevel, Mogre::PatchSurface::VisibleSide visibleSide, Mogre::HardwareBuffer::Usage vbUsage, Mogre::HardwareBuffer::Usage ibUsage, bool vbUseShadow, bool ibUseShadow );
      </_CustomIncDeclaration>
      <_CustomCppDeclaration>
        generic&lt;typename T> where T : value class
        Mogre::PatchMeshPtr^ MeshManager::CreateBezierPatch( String^ name, String^ groupName, array&lt;T>^ controlPointArray, Mogre::VertexDeclaration^ declaration, size_t width, size_t height, size_t uMaxSubdivisionLevel, size_t vMaxSubdivisionLevel, Mogre::PatchSurface::VisibleSide visibleSide, Mogre::HardwareBuffer::Usage vbUsage, Mogre::HardwareBuffer::Usage ibUsage, bool vbUseShadow, bool ibUseShadow )
        {
        DECLARE_NATIVE_STRING( o_name, name )
        DECLARE_NATIVE_STRING( o_groupName, groupName )
        pin_ptr&lt;T> buf = &amp;controlPointArray[0];

        return static_cast&lt;Ogre::MeshManager*>(_native)->createBezierPatch( o_name, o_groupName, buf, declaration, width, height, uMaxSubdivisionLevel, vMaxSubdivisionLevel, (Ogre::PatchSurface::VisibleSide)visibleSide, (Ogre::HardwareBuffer::Usage)vbUsage, (Ogre::HardwareBuffer::Usage)ibUsage, vbUseShadow, ibUseShadow );
        }
      </_CustomCppDeclaration>
    </class>

    <class name="SceneManager">
      <_CustomIncDeclaration>
        public:
        // Custom overloads for setting/getting SceneManager options

        bool SetOption( String^ strKey, bool value )
        {
        return SetOption(strKey, &amp;value);
        }
        bool GetOption( String^ strKey, [Out] bool% value )
        {
        pin_ptr&lt;bool> p = &amp;value;
        return GetOption(strKey, p);
        }

        bool SetOption( String^ strKey, int value )
        {
        return SetOption(strKey, &amp;value);
        }
        bool GetOption( String^ strKey, [Out] int% value )
        {
        pin_ptr&lt;int> p = &amp;value;
        return GetOption(strKey, p);
        }

        bool SetOption( String^ strKey, Real value )
        {
        return SetOption(strKey, &amp;value);
        }
        bool GetOption( String^ strKey, [Out] Real% value )
        {
        pin_ptr&lt;Real> p = &amp;value;
        return GetOption(strKey, p);
        }

        bool SetOption( String^ strKey, String^ value )
        {
        DECLARE_NATIVE_STRING( o_str, value )
        return SetOption(strKey, &amp;o_str);
        }
        bool GetOption( String^ strKey, [Out] String^% value )
        {
        Ogre::String o_str;
        bool ret = GetOption(strKey, &amp;o_str);
        if (ret)
        {
        value = TO_CLR_STRING( o_str );
        }

        return ret;
        }

        bool SetOption( String^ strKey, Mogre::Vector3 value )
        {
        return SetOption(strKey, &amp;value);
        }
        bool GetOption( String^ strKey, [Out] Mogre::Vector3% value )
        {
        pin_ptr&lt;Mogre::Vector3> p = &amp;value;
        return GetOption(strKey, p);
        }

        bool SetOption( String^ strKey, Mogre::Vector2 value )
        {
        return SetOption(strKey, &amp;value);
        }
        bool GetOption( String^ strKey, [Out] Mogre::Vector2% value )
        {
        pin_ptr&lt;Mogre::Vector2> p = &amp;value;
        return GetOption(strKey, p);
        }

        bool SetOption( String^ strKey, Mogre::Quaternion value )
        {
        return SetOption(strKey, &amp;value);
        }
        bool GetOption( String^ strKey, [Out] Mogre::Quaternion% value )
        {
        pin_ptr&lt;Mogre::Quaternion> p = &amp;value;
        return GetOption(strKey, p);
        }
      </_CustomIncDeclaration>
    </class>

    <class name="RenderTarget">
      <_CustomIncDeclaration>
        public:
        // Custom overloads for getting custom attributes

        void GetCustomAttribute( String^ name, [Out] bool% value )
        {
        pin_ptr&lt;bool> p = &amp;value;
        GetCustomAttribute(name, p);
        }

        void GetCustomAttribute( String^ name, [Out] int% value )
        {
        pin_ptr&lt;int> p = &amp;value;
        GetCustomAttribute(name, p);
        }

        void GetCustomAttribute( String^ name, [Out] IntPtr% value )
        {
        pin_ptr&lt;IntPtr> p = &amp;value;
        GetCustomAttribute(name, p);
        }
      </_CustomIncDeclaration>
    </class>
  </namespace>
</meta>
